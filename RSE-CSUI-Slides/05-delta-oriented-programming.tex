\documentclass[aspectratio=1610,10pt,handout]{beamer}
\setbeameroption{show notes}
\usepackage{pgfpages}

%% Additional macro to read local beamer themes from a specific directory
\makeatletter
\def\beamer@calltheme#1#2#3{%
	\def\beamer@themelist{#2}
	\@for\beamer@themename:=\beamer@themelist\do
	{\usepackage[{#1}]{\beamer@themelocation/#3\beamer@themename}}}

\def\usefolder#1{
	\def\beamer@themelocation{#1}
}
\def\beamer@themelocation{}

\usefolder{Theme}
\usetheme[
%%% options passed to the outer theme
%    hidetitle,           % hide the (short) title in the sidebar
%    hideauthor,          % hide the (short) author in the sidebar
%    hideinstitute,       % hide the (short) institute in the bottom of the sidebar
%    shownavsym,          % show the navigation symbols
%    width=2cm,           % width of the sidebar (default is 2 cm)
%    hideothersubsections,% hide all subsections but the subsections in the current section
%    hideallsubsections,  % hide all subsections
    left               % right of left position of sidebar (default is right)
%%% options passed to the color theme
%    lightheaderbg,       % use a light header background
  ]{FasilkomUIsidebar}

% If you want to change the colors of the various elements in the theme, edit and uncomment the following lines
%%%% Template for Blue-Red Color theme %%%%
% Header color (Red)
\definecolor{beamer@headercolor}{RGB}{200,0,0}% red
%% Change the bar and sidebar colors:
\setbeamercolor{FasilkomUIsidebar}{fg=beamer@barcolor,bg=csui@red}
\setbeamercolor{sidebar}{bg=csui@blue}
%% Change the color of the structural elements:
\setbeamercolor{structure}{fg=gray}
%% Change the frame title text color:
\setbeamercolor{frametitle}{bg=csui@red}
%% Sidebar font color
\setbeamercolor{section in sidebar}{fg=white}
\setbeamercolor{section in sidebar shaded}{fg=gray}
\setbeamercolor{subsection in sidebar}{fg=white}
\setbeamercolor{subsection in sidebar shaded}{fg=gray}

\setbeamersize{text margin left=0.5cm, text margin right=0.5cm}

% Custom template designed only for 2-in-1 handout
% Notes are served as plain, unformatted page
\setbeamertemplate{note page}{
  \vbox{
    \vskip-2em
    \hbox{
      \hskip-3.5em
      \vbox{
        \hsize\paperwidth
        \insertnote
      }
    }
  }
}

%%%% End of - Template for Blue-Red Color theme %%%%
% ... and you can of course change a lot more - see the beamer user manual.


\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.
\usepackage{helvet}

% colored hyperlinks
\newcommand{\chref}[2]{%
  \href{#1}{{\usebeamercolor[bg]{FasilkomUIsidebar}#2}}%
}

\newcommand{\lc}{$\lambda$ {\it calculus}\ }

\title[SPLE 2022]% optional, use only with long paper titles
{Software Product Line Engineering 2025}

\subtitle{Simply Typed $\lambda$ Calculus}  % could also be a conference name

\date{TBD}

\author[HSF] % optional, use only with lots of authors
{
  Hafiyyan Sayyid Fadhlillah\\
  \href{mailto:hafiyyan@cs.ui.ac.id}{{\tt hafiyyan@cs.ui.ac.id}}
}
% - Give the names in the same order as they appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation. See the beamer manual for an example

\institute[
%  {\includegraphics[scale=0.2]{aau_segl}}\\ %insert a company, department or university logo
  Fakultas Ilmu Komputer\\
  Universitas Indonesia
] % optional - is placed in the bottom of the sidebar on every slide
{% is placed on the title page
  Fakultas Ilmu Komputer\\
  Universitas Indonesia

  %there must be an empty line above this line - otherwise some unwanted space is added between the university and the country (I do not know why;( )
}

% specify a logo on the titlepage (you can specify additional logos an include them in
% institute command below
%\pgfdeclareimage[height=1.5cm]{titlepagelogo}{AAUgraphics/aau_logo_new} % placed on the title page
%\pgfdeclareimage[height=1.5cm]{titlepagelogo2}{graphics/aau_logo_new} % placed on the title page
%\titlegraphic{% is placed on the bottom of the title page
%  \pgfuseimage{titlepagelogo}
%%  \hspace{1cm}\pgfuseimage{titlepagelogo2}
%}

\begin{document}

% For handout 1 slide + 1 note per page
\pgfpagesuselayout{2 on 1}[a4paper,border shrink=5mm]
\pgfpagesphysicalpageoptions{logical pages=2, physical height=0.9\pgfphysicalheight, physical width=\pgfphysicalwidth}

% the titlepage
{\uilogograybg % gray background
%\uilogotitle	% white background
\setbeamercolor{title}{fg=white}	% font color of the presentation title is changable depending on the background color
\setbeamercolor{frametitle}{use=structure,fg=black!80,bg=beamer@barcolor}
\begin{frame}[plain,noframenumbering] % the plain option removes the sidebar and header from the title page
  \titlepage
\end{frame}}
%%%%%%%%%%%%%%%%

\begin{frame}{Agenda}{}
\tableofcontents
\end{frame}
%%%%%%%%%%%%%%%%

\section{Pengantar}

%\begin{frame}{Perubahan Paradigma Berfikir}{}
%
%	\begin{block}{Alvin Toffler, Powershift: Knowledge, Wealth, and Power at the Edge of the 21st Century, 1990 }
%		\pause
%		The illiterate of the 21st century will not be those who cannot read and write, but those who cannot learn, unlearn, and relearn.
%	\end{block}
%
%	\begin{itemize}
%		\pause
%		\item Sebelum mempelajari syntax, semantic dari bahasa pemrograman yang baru, perlu dipelajari dulu paradigma dan filosofi bahasa tersebut
%		\pause
%		\item Untuk dapat mempelajari yang baru kita harus perlu dapat melupakan (mengesampingkan) yang lama dulu. (Minimal untuk sementara)
%	\end{itemize}
%
%\end{frame}

\begin{frame}{$\lambda$ (Lambda) Calculus }{Paparan singkat informal}

  \begin{itemize}
    \item<1-> Kata "{\bf kalkulus}" secara umum berarti sistem baku (formal) untuk aturan inferensi dan aksioma.
    \item<2-> \lc adalah sebuah sistem baku untuk aturan inferensi dan aksioma yang ditandai dengan symbol $\lambda$ untuk memodelkan komputasi berfokus/berbasis \bf{ekspresi}.
    \item<3-> \it{The smallest universal programming language}. Dapat digunakan untuk mensimulasi \textit{turing machine}.
    \item<4-> Diperkenalkan oleh Alonzo Church tahun 1930-an. Pembimbingan doctor dari Alan Turing.
   	\item<5-> Jauh diformulasikan sebelum komputer merupakan barang yang populer.
  \end{itemize}
  \note{
    Berikut ini adalah contoh note di dalam slide.
    Apabila dokumen LaTeX ini sudah diatur dengan benar,
    seharusnya akan ada section khusus menampilkan handout berisikan note ini.

    abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode abode 
  }
\end{frame}
%%%%%%%%%%%%%%%%

\begin{frame}{$\lambda$ Ekspresi}{}

	\begin{itemize}

		\item Dalam \lc ada tiga jenis ekspresi, yaitu:
		\begin{enumerate}
			\item variabel ($a,b,c,d$)
			\item aplikasi (\it{application})
			\item fungsi (\it{abstraction})
		\end{enumerate}
		\pause
		\item Secara formal didefinisikan rekursif sebagai berikut:
		\begin{tabular}{r c l}
			<ekspresi> & := & <nama> | <fungsi> | <aplikasi> \\
			<fungsi> & := & $\lambda$ <nama>. <ekspresi> \\
			<aplikasi> & := & <ekspresi> <ekspresi>
		\end{tabular}

		\item nama variabel biasanya dinyatakan oleh huruf kecil (a,b,c,...)


	\end{itemize}
\end{frame}

\begin{frame}{Asosiatif dalam aplikasi}
	\begin{enumerate}
	\item Ekspresi bisa diberikan tanda kurung.
	\item jika $E$ adalah ekspresi, maka $(E)$ adalah ekspresi juga.
	\item selain variable dan tanda kurung, simbol lain adalah $lambda$ dan tanda titik {\bf .} (dot).
	\item untuk mengurangi tanda kurung, disepakati asosiatif ke kiri yang artinya penulisan sebagai berikut:
	$$E_1 E_2 E_3 E_4$$
	sama dengan
	$$ (((E_1 E_2) E_3) E_4) $$
	\end{enumerate}

\end{frame}

\begin{frame}{Fungsi}{Sebuah $\lambda$ Ekspresi}

	\begin{enumerate}
		\item<1-> Ekspresi: $$\lambda x. y$$ adalah sebuah fungsi
		\item<2-> variable $x$ setelah simbol $\lambda$ menyatakan argumen untuk fungsi tersebut.
		\item<3-> variable $y$ setelah simbol . ({\it dot}) adalah isi ({\it body}) dari fungsi tersebut.
	\end{enumerate}
\end{frame}

\begin{frame}{Fungsi dalam fungsi}{Sebuah $\lambda$ Ekspresi}

	\begin{itemize}
		\item<1-> di dalam isi sebuah fungsi, bisa berupa ekspresi lagi yang ekspresinya bisa berbentuk salah satu dari tiga bentuk tersebut (variable, fungsi, application)
		\item<2-> Ekspresi: $$\lambda x. \lambda y. z $$ adalah sebuah fungsi.
		\item<3-> Fungsi tersebut diatas memiliki argumen $x$ yang di dalam $isi$ fungsi tersebut, terdapat fungsi lain. Fungsi yang berada di dalam memiliki argument $y$ dan isinya adalah $z$
	\end{itemize}
\end{frame}

\subsection{Terminologi}
\begin{frame}{Terminolog}{Fungsi, $\lambda$ ekspresi,  dan aplikasi fungsi}

	\begin{itemize}
		\item<1-> Ekspresi: $$\lambda x. x$$ adalah sebuah fungsi identitas
		\item<2-> Sebuah ekspresi bisa di-{\bf aplikasi}-kan kepada sebuah ekspresi.
		\item<3-> Ekspresi: $$(\lambda x. x) y$$ adalah aplikasi ekspresi $y$
		(yang dalam hal ini adalah variable) kepada fungsi indentitas tersebut.
		\item<4-> {\bf Aplikasi fungsi} adalah proses meng-substitusi kehadiran variable pada argument $x$ dengan ekspresi $y$ yang artinya setiap kemunculan variable $x$ dalam isi fungsi tersebut akan digantikan oleh variable $y$.
		 $$(\lambda x. x) y \equiv y $$
	\end{itemize}
\end{frame}

\subsection{$\beta$ (beta) Reduction}
\begin{frame}{$\beta$ (beta) Reduction}{\lc}

	\begin{itemize}
		\item Secara umum aplikasi $$(\lambda v. E_1) E_2$$ dievaluasi sebagai $$E_1[v:=E_2]$$
		\item dibaca sebagai kehadiran variabel $v$ didalam $E_1$ digantikan dengan $E_2$.
		\item Aturan ini secara formal disebut {\bf $\beta$ (beta) reduction}
		\item Contoh:
		\[
		\begin{array}{l}
		(\lambda x. (\lambda y. x)) z \\
		\equiv (\lambda y. x)[x:= z] \\
		\equiv (\lambda y. z)\\
		\end{array}
		\]
	\end{itemize}
\end{frame}


\begin{frame}{variabel bebas dan variable terikat}{\lc}

	\begin{itemize}
		\item dalam \lc nama variabel adalah berlaku local didalam definisi tersebut.
		\item dalam ekspresi $$\lambda y. y$$ variabel $y$ dikatakan {\bf terikat}, sementara variable lain yang tidak didahului oleh simbol $\lambda$ dikatakan sebagai variabel {\bf bebas}
		\item Misalkan pada ekspress:
		$$\lambda x. xy$$
		maka variabel $x$ terikat dan variabel $y$ dinyatakan bebas.
		\pause
		\item pada contoh berikut: $$(\lambda x. x)(\lambda y. yx)$$
		perhatikan bahwa variable $x$ di ekspresi sebelah kiri terikat, tapi variabel $x$ di ekspresi sebelah kanan adalah bebas. Kedua variable $x$ tersebut menyatakan hal yang berbeda.

	\end{itemize}
\end{frame}


\begin{frame}{observasi: Fungsi Identitas}{\lc}

	\begin{itemize}
		\item fungsi identitas $$\lambda x. x$$
		\item Contoh evaluasi:
		\[
		\begin{array}{l}
		(\lambda x. x) z \\
		\equiv x[x:= z] \\
		\equiv z\\
		\end{array}
		\]
		\pause
		\item fungsi $$\lambda y. y$$ adalah juga fungsi identitas
		\item Contoh evaluasi:
		\[
		\begin{array}{l}
		(\lambda y. y) z \\
		\equiv y[y:= z] \\
		\equiv z\\
		\end{array}
		\]

	\end{itemize}
	\pause
	\alert{
		secara umum variabel terikat didalam sebuah ekspresi bisa diganti dengan variabel baru lain, asalkan variable baru tersebut tidak muncul bebas dialam ekspresi tersebut.
	}
\end{frame}

\subsection{$\alpha$ (alpha) Conversion}
\begin{frame}{$\alpha$ (alpha) Conversion}{\lc}
	\begin{itemize}
		\item secara general setiap variable bisa digantikan dengan variabel lain dan tetap menyatakan ekspresi yang sama (asalkan dilakukan secara konsisten).
		\item Contoh evaluasi:
		\[
		\begin{array}{l}
		(\lambda x. x) z \\
		\equiv x[x:= z] \\
		\equiv z\\
		\end{array}
		\]

		\item fungsi $$\lambda y. y$$ adalah juga fungsi identitas
		\item Contoh evaluasi:
		\[
		\begin{array}{l}
		(\lambda y. y) z \\
		\equiv y[y:= z] \\
		\equiv z\\
		\end{array}
		\]
		\item secara umum variabel didalam sebuah ekspresi bisa secara konsisten diganti
	\end{itemize}
\end{frame}


\subsection{$\eta$ (eta) Reduction}
\begin{frame}{$\eta$ (eta) Reduction}{\lc}
	\begin{itemize}
		\item Menyatakan sebuah reduksi yang menghilang variable.
		Contoh:

		$$f\ x = g\ x  \equiv f = g$$

		\item Seperti \textit{point free style}
	\end{itemize}
\end{frame}


\section{Evaluasi dan Substitusi}
% motivation for creating this theme
\begin{frame}{Fungsi tidak punya nama}{\lc }

	\begin{itemize}
		\item<1-> Dalam \lc, setiap fungsi tidak diberi nama.
		\item<1-> Dalam mengevaluasinya kita perlu menuliskan keseluruhan fungsi.
		\item<2-> Misalkan fungsi identitas nyatakan equivalen dengan ekspresi $I \equiv (\lambda x.x)$
		\item<2-> Ekspresi $I$ merupakan synonim dengan fungsi identitas tersebut.
		\item<3-> Fungsi identitas $I$ bisa kita aplikasikan dengan fungsi itu sendiri:
		$$ I I \equiv (\lambda x.x) (\lambda x.x)$$
		\item<3-> sebagaimana observasi sebelumnya, untuk menghindari kebingungan dengan adanya variabel yang sama tapi mungkin punya makna berbeda, kita dapat mengubah variable di salah salah ekspresi dengan menerapkan $\alpha-conversion$ menjadi
		$$ I I \equiv (\lambda x.x) (\lambda z.z)$$
		\item<4-> Evaluasi ekspresi tersebut:
		\[
		\begin{array}{l}
		I I \equiv (\lambda x.x) (\lambda z.z)\\
		\equiv x [x:= (\lambda z.z)] \\
		\equiv (\lambda z.z) \\
		\equiv I \\
		\end{array}
		\]
	\end{itemize}
\end{frame}
%%%%%%%%%%%%%%%%
\begin{frame}{Tidak mencampur variabel bebas dan variabel terikat}{\lc }

	\begin{itemize}
		\item<1-> Ketika melakukan substitusi, kita perlu hati-hati agar tidak mencampur antara variable bebas dengan variabel terikat.
		\item<1-> Misalkan ekspresi berikut ini
		$$(\lambda x. (\lambda y. xy)) y$$
		\item<2-> Perhatikan variabel $y$ pada $xy$ adalah terikat, sementara variabel $y$ yang paling kanan adalah bebas.

		\item<3-> Substitusi yang keliru akan menghasilkan:
		\[
		\begin{array}{l}
		(\lambda x. (\lambda y. xy)) y \\
		\equiv (\lambda y. xy) [x:= y] \\
		\equiv (\lambda y.yy) \\
		\end{array}
		\]
		\item<3-> kedua variabel $y$ yang mungkin berbeda,  akhirnya kedua jadi terikat dan harus sama.
		\item<4-> Sebelum di evaluasi, seharusnya bisa diganti dulu variabel terikat nya, yaitu:
		\[
		\begin{array}{l}
		(\lambda x. (\lambda y. xy)) y \\
		\equiv (\lambda x. (\lambda t. xt)) y \\
		\equiv (\lambda t. xt) [x:= y] \\
		\equiv (\lambda t.yt) \\
		\end{array}
		\]

	\end{itemize}
\end{frame}
%%%%%%%%%%%%%%%%

\section{Representasi}

\subsection{Church Numerals}

\begin{frame}{Representasi bilangan cacah}{\lc: Church Numerals}

	\begin{itemize}
		\item<1-> Sebuah bahasa pemrograman perlu dapat merepresentasikan bilangan
		\item<2-> Sebelumnya kita telah pelajari bagaimana representasi bilangan dinyatakan secara simbol (gambar), \item<3-> kemudian ketika kuliah kita mempelajari bahwa bilangan bisa dinyatakan secara binary berdasarkan signal listrik.
		\item<4-> Pada kali ini kita akan pelajari bagaimana {\bf bilangan dinyatakan sebagai fungsi} dalam \lc
	\end{itemize}
\end{frame}


% motivation for creating this theme
\begin{frame}{Representasi bilangan cacah}{\lc: Church's Numerals}

	\begin{itemize}
		\item<1-> $0 \equiv \lambda s. (\lambda z. z)$
		\item<2-> Bila ada symbol $\lambda$ bersarang biasa nya dipersingkat penulisnya menjadi:\\

		$ 0 \equiv \lambda s z. z$
		 \item<3-> $ 1 \equiv \lambda s z. s (z))$
		 \item<4-> $ 2 \equiv \lambda s z. s (s (z)))$
		 \item<5-> $ 3 \equiv \lambda s z. s (s (s (z))))$
		 \item<5-> dan seterusnya
	\end{itemize}


\end{frame}


% motivation for creating this theme
\begin{frame}{Representasi bilangan cacah}{\lc: Church's Numerals}

	\begin{itemize}
		\item<1-> Di \lc ada sebuah fungsi yang disebut fungsi $successor$ dengan simbol $S$.

		\item<2-> Fungsi tersebut dapat memodelkan bilangan secara unary: 1 = S(0), 2=S(S(0)) dan seterusnya.

		\item<3-> Definisinya: $$ S \equiv \lambda w y x. y (wyx) $$
	\end{itemize}

\end{frame}

\subsubsection{Penjumlah}

\begin{frame}{Penjumlahan}{\lc }

	\begin{itemize}
		\item<1-> Misalkan kita ingin menjumlahkan $$2+3$$

		\item<2-> dalam \lc dapat dimodelkan dengan $$2S3$$

		\item<3-> $2S3 \equiv (\lambda sz. s(s(z))) (\lambda w y x. y (wyx)) (\lambda u v. u (u (u (v)))))  $

		\item<4-> apakah bila dievaluasi benar hasilnya 5?
		\item<5-> Mari coba dulu yang lebih sederhana dengan $$0+1$$ $$0S1$$ apakah benar hasilnya 1?
	\end{itemize}

\end{frame}

\subsubsection{Perkalian}

\begin{frame}{Perkalian}{\lc }

	\begin{itemize}
		\item<1-> Perkalian adalah pengulangan penjumlahan dan dapat dimodelkan dengan $$\lambda x y z. x (y z) $$

		\item<2-> Perkalian $$0 x 1$$ dimodelkan dengan $$ (\lambda x y z. x (y z)) 0 1 $$

		\item<2-> Pada penulisan kali ini kita perkenalkan 'literal 0 dan 1' yang kelak akan dikembalikan kepada definisi representasinya di \lc

		\item<3->
		\[
		\begin{array}{lr}
		0*1 & \\

		\pause
		\equiv  (\lambda x y z. x (y z)) 0 1  & $representasi dari $ 0*1 \\

		\pause
		\equiv  (\lambda y z. 0 (y z)) 1 & $aplikasi 0,$ x:=0 \\

		\pause
		\equiv  (\lambda z. 0 (1 z))  & $aplikasi 1,$ y:= 1 \\

		\pause
		\equiv  (\lambda z. (\lambda s. (\lambda t. t)) (1 z))  & $membuka definisi literal $ 0
		\equiv (\lambda s. (\lambda t. t)) \\
		\pause

 		\equiv  (\lambda z. (\lambda s. (\lambda t. t)) (1 z))  & $aplikasi $ (1 z), s:= (1 z) \\

 		\pause
		\equiv  (\lambda z. (\lambda t. t)))  & $definisi $ 0 \\
		\equiv  0 &  \\
		\end{array}
		\]

		\item<4-> Bagaimana dengan perkalian $1 * 2$ (Kita akan berlatih dan kerjakan bersama)?

	\end{itemize}
	\end{frame}

\subsection{Church Boolean}
\subsubsection{True False}
	\begin{frame}{Kondisi Bersyarat (If-then-else)}{\lc: Church Boolean}

			\begin{description}
				\item [$T$] (true) dinyatakan dengan $\lambda x y. x$
				\item [$F$] (false) dinyatakan dengan $\lambda x y. y$
			\end{description}
			\pause
			Contoh: Bagaimana menyatakan {\bf  if $P$ then $E_1$ else $E_2$}
			\pause
			\begin{itemize}
				\item<2-> $P$ adalah sebuah propotional yang hanya dapat berisi benar atau salah.
				\item<3-> Dengan kata lain, $P$ dinyatakan sebuah variable yang bisa berisi literal $T$ atau $F$.
				\item<4-> sehingga peryataan tersebut bisa dituliskan dalam \lc dengan
				$$P E_1 E_2 $$
				\item<5-> Bila $P$ adalah benar ($T$) maka\[
				 \begin{array}{lr}
				P E_1 E_2 & P $ adalah true$ \\
				\equiv (\lambda x y. x ) E_1 E_2 & \beta-reduction \\
				\equiv E_1 & \\
				 \end{array}
				 \]
				\item<5-> Bila $P$ adalah false ($F$) maka\[
				\begin{array}{lr}
				P E_1 E_2  & P $ adalah false$ \\
				\equiv (\lambda x y. y ) E_1 E_2 & \beta-reduction \\
				\equiv E_2 & \\
				\end{array}
				\]

			\end{itemize}
	\end{frame}

\subsubsection{Operasi Logika}
\begin{frame}{Operasi Logika}{\lc: Church's Boolean}

	\begin{description}
		\item [Conjuntion (and)] ($\wedge$) dinyatakan dengan
		$$\wedge \equiv \lambda xy. xy(\lambda uv. v) \equiv  \lambda xy. xyF$$
		\item [Disjunction (or)] ($\vee$) dinyatakan dengan
		$$\vee  \equiv \lambda xy.x(\lambda uv.u)y \equiv \lambda xy.xTy$$
		\item [Negation (not)] ($\neg$) dinyatakan dengan
		$$ \lambda x.x(\lambda uv.v)(\lambda ab.a) \equiv  \lambda x.xFT $$
	\end{description}
	\pause
	\begin{itemize}
		\item Contoh: $\neg T \equiv F$.

		\[
		\begin{array}{lr}
		\neg T & definisi\ \neg  \\
		\equiv (\lambda x.xFT) T  & \beta-reduction \\
		\equiv TFT & definisi\ T \\
		\equiv (\lambda xy. x) F T & \beta-reduction  \\
		\equiv F  &  \\
		\end{array}
		\]

	\end{itemize}
\end{frame}

\begin{frame}{Test zero}{\lc}

	Dalam beberapa bahasa pemrograman akan sangat bermanfaat bila
	memiliki fungsi yang menguji apakah suatu variabel bernilai 0 atau tidak.

	Untuk kebutuhan tersebut misalkan kita definisikan
	$$ Z \equiv  \lambda x. x F \neg F $$

	Untuk memahami cara kerjanya, perhatikan bahwa:
	$$ 0 f a \equiv (\lambda s z. z) f a \equiv a $$
	yang artinya fungsi $f$, diaplikasikan dengan  $a$ sebanyak 0 kali sehingga tetap a.

	\pause
	Perhatikan juga bahwa bila fungsi $F$ diaplikasikan dengan apapun, maka akan menghasilkan fungsi identitas $I$.
	$$Fa \equiv (\lambda x y . y ) a \equiv \lambda y.y \equiv I$$

	Sekarang kita perhatikan bagaimana cara kerja fungsi $Z$ ini. Perhatikan fungsi $Z$ diaplikasi dengan 0.
	\[
	\begin{array}{rlr}
    Z0 \equiv & (\lambda x.xF \neg F)0   & $definisi Z dan $ \beta-reduction \\
         \equiv & 0F \neg F & $karena F diaplikasi dengan $ \neg F $ sebanyak 0 kali$ \\
         \equiv &  \neg F &  \\
         \equiv & T   & \\
    \end{array}
	\]

\end{frame}

\begin{frame}{Test zero}{\lc}
	Representasi {\it church numeral}, menyatakan bilangan sebagai enumerasi yang merupakan fungsi menerima fungsi dan argumen kemudian menerapkan fungsi tersebut terus menerus sebanyak enumerasinya.

	Ingat bahwa bila fungsi $F$ diaplikasikan dengan apapun, maka akan menghasilkan fungsi identitas $I$.
	$$Fa \equiv (\lambda x y . y ) a \equiv \lambda y.y \equiv I$$

	Perhatikan fungsi $Z$ diaplikasi dengan bilangan bukan 0, misalkan N.
	\[
	\begin{array}{rlr}
	ZN \equiv & (\lambda x.xF \neg F)N & $definisi Z dan $ \beta-reduction \\
	\equiv & NF \neg F & $karena F diaplikasi dengan $ \neg F $ sebanyak N kali, hasilnya I $ \\
	\equiv &  I F &  \\
	\equiv & F  & \\
	\end{array}
	\]

\end{frame}

\begin{frame}{Predecessor (Nilai sebelumnya)}{\lc}
	Untuk menghitung nilai sebelumnya, digunakan representasi pair $(n, n-1)$ elemen kedua dari pair dinyatakan sebagai $predessor$.  Sebuah $pair(a,b)$ dinyatakan dalam \lc dengan
	$$ (a,b) \equiv \lambda z. z a b$$

	Untuk mengambil elemen pertama, fungsi pair tersebut di aplikasikan dengan $T$.
	$$ first (a,b) \equiv (\lambda z. z a b) T \equiv Tab \equiv a $$

	dan untuk mengambil elemen kedua, fungsi pair tersebut diaplikasikan dengan $F$.
	$$ second (a,b) \equiv (\lambda z. z a b) F \equiv Fab \equiv b $$

	Untuk dapat menggenerate pair ke-n, didefinisikan fungsi generator: $$\Phi \equiv (\lambda pz. z(S(pT))(pT)) $$

	Fungsi predecessor didefinisikan dengan sebelumnya menggenerate pair ke-n, kemudian mengambil elemen kedua. Generator akan menerapkan sebanyak n kali dari inisialisasi awal yaitu  $\lambda z.z00$. Perhatikan bahwa kita memodelkan sehingga dianggap predecessor dari 0 adalah 0. Dengan acuan tersebut didefinisikan:
	$$ P \equiv (\lambda n. n\ \Phi (\lambda z.z00)F )$$

\end{frame}

\subsubsection{Equality dan inequalities}
\begin{frame}{Equality dan inequalities}{\lc}

Dengan memanfaatkan definisi predecessor $P$ kita bisa definisikan "predikat lebih besar sama dengan" ($\geq $)  kita simbolkan dengan $G$ sebagai berikut:
$$ G \equiv (\lambda xy.Z(xPy))$$

Ini artinya kita memeriksa, apakah bila fungsi predecessor $P$ diaplikasikan dengan $y$ sebanyak $x$ kali akan menghasilkan $0$ atau tidak. Bila $x$ lebih besar atau sama dengan $y$ maka hasilnya akan 0, karena $y$ akan dikurangi satu kali terus menerus sebanyak $x$ kali. Berlaku juga sebaliknya.
Bila hasilnya 0, maka fungsi penguji $Z$ akan memberikan jawaban $T$ (true).

Untuk mendefinisikan persamaan ($equality$) dari bilangan didefinisikan $E$:
$$ E \equiv (\lambda xy. \wedge (Z(xPy))(Z(yPx))) $$

yang menyatakan bahwa bila $x\geq y$ dan $y \geq x$ maka $x=y$

\end{frame}

\subsection{Rekursif}
\begin{frame}{Rekursif}{\lc}

	Definisi rekursif dimodelkan dalam \lc dengan fungsi yang disebut $Y$ dan fungsi tersebut me-regenerate fungsi kembali. Didefinisikan sebagai berikut:
	$$ Y \equiv  (\lambda y.(\lambda x.y(xx))(\lambda x.y(xx))) $$

	Bagaimana penerapan-nya? Misalkan ada sebuah fungsi rekursif $R$.
	\[
	\begin{array}{rlr}
	YR \equiv  &  ((\lambda x.R(xx))(\lambda x.R(xx)))  &  definisi \\
	     \equiv  & R((\lambda x.R(xx))(\lambda x.R(xx)))) & \beta-reduction \\
	     \equiv  & R(YR) & rekursif \\
	 \end{array}
	\]
	Dengan kata lain, bila fungsi $Y$ diaplikasikan dengan sebuah fungsi $R$, maka akan menghasilkan pemanggilan rekursi dari fungsi $R$ tersebut.

	Contoh:
	$$ \Sigma_{i=0}^n i = n + \Sigma_{i=0}^{n-1} i  $$
\end{frame}

\begin{frame}{Rekursif}{\lc}


	$$ Y \equiv  (\lambda y.(\lambda x.y(xx))(\lambda x.y(xx))) $$

	Contoh:
	$$ \Sigma_{i=0}^n i = n + \Sigma_{i=0}^{n-1} i  $$
	\pause

	Fungsi rekursif tersebut diberi nama $R$ dan dimodelkan dalam \lc menjadi:
	$$ R \equiv  (\lambda rn.Zn0(nS(r(Pn)))) $$

	\pause
	Misalkan dengan parameter $n=3$, penerapan rekursifnya menjadi:

	$$YR3 = R(YR)3 = Z30(3S(YR(P3)))$$
	\pause
	Karena 3 tidak sama dengan 0, maka menjadi:
	$$3S(YR2)$$
	\pause
	Bila kembali diterapkan definisi $Y$, maka akan didapat:
	$$3S(YR2) \equiv 3S(2S(YR1)) \equiv 3S(2S(1S0)) \equiv 6 $$



\end{frame}

%\section{Aturan lain}
%
%	\begin{frame}{Aturan lain}{\lc }
%		\begin{block}{Beberapa aturan lain dalam \lc}
%		\begin{description}
%			\item [$\eta$ (eta) reduction], menghilangkan $\lambda$
%			$$ (\lambda x. f x) \equiv f$$
%			\item [$\lambda$ (lambda) abstraction], menambahkan $\lambda$
%			$$ f \equiv (\lambda x. f x)$$
%
%		\end{description}
%		\end{block}
%	\end{frame}

\section{Type System}

	\begin{frame}{Motivasi: Simply Typed Lambda Calculus }{}
		\begin{block}{Sebuah Paradox}
			Perhatikan kalimat berikut:
			\pause

			{\LARGE {\center
				\alert{Saya seorang pembohong}
			}}
		\end{block}
	\end{frame}


	\begin{frame}{Russel's Paradox}{Motivasi: Simply Typed Lambda Calculus }
		{\it Barber Paradox} \vspace{1cm}

		{\Large  A barber (who is a man) shaves all and only those men who do not shave themselves.

			\vspace{1cm}
			Does he shave himself?}

		\pause
		\vspace{1cm}
		{\it Na\"ive Comprehension (NC)}

		$$(NC) \exists A . \forall . x (x \in A \equiv  \Phi )$$

		where $A$ is not free in the formula $\Phi$. This says, “There is a set $A$ such that for any object $x$, $x$ is an element of $A$ if and only if the condition expressed by $\Phi$ holds.” Russell’s paradox arises by taking $\Phi$  to be the formula: $x \notin x$.

	\end{frame}

	\note{Na\"ive Comprehension in Contemporary Logic. When set theory is na\"ive.
		 https://plato.stanford.edu/entries/russell-paradox/  }


\subsection{Abstract Syntax}
\begin{frame}{Abstract Syntax}{Simple Type \lc }

	\[
	\begin{array}{rcl}
	T, U &\in& \mathbf{Type} \\
	T, U &::=& T \to U \\
	&& \cdots\\
	x,y,z &\in& \mathbf{Var} \\
	t,u &\in& \mathbf{Term} \\
	t,u &::=& x \\
	&\mid& t\,u \\
	&\mid& \lambda {x:T}\cdot t \\
	&& \cdots
	\end{array}
	\]

	Simbol $\dots$ menyatakan bagian dari bahasa atau tipe yang relatif sudah kita
	kenal dan tidak membutuhkan $pure-types$.

	Pada Simply Type $\lambda$ Calculus, tipe dinyatakan sebagai sebuah elemen, dalam paparan kali ini dengan huruf $T$, dan $U$. Penulisan $x:T$ dibaca sebagai sebuah term atau variable $x$ bertipe $T$. Tipe dapat juga berupa aplikasi fungsi diantara dua tipe $T \to U$.

	Berbeda dengan asosiatif pada fungsi aplikasi, pada penulisan tipe asosiatif yang digunakan adalah asosiatif ke kanan.

\end{frame}

\subsection{Type Judgement}
\begin{frame}{Type Judgement}{Simple Type \lc }

	Dengan adanya penerapan sistem tipe ({\it type system}) sebuah prosedur pemeriksaan
	tipe akan dibutuhkan. Prosedur tersebut di literatur disebut dengan istilah
	\emph{type judgment}.
%	Terjemahan langsung dalam bahasa indonesia akan
%	berarti: \emph{Pengadilan Jenis}. Untuk menghidari kebingungan kita akan tetap
%	gunakan istilah \emph{type judgment} dan beberapa istilah terkait lain nya seperti $term$ dan $type$.

	Prosedur \emph{type judgment} memiliki tiga komponen yaitu:

	\begin{itemize}
		\item  \emph{type environment}, berisi semacam $dictionary$ yang memetakan
		variable yang berada dalam $term$ ke $type$.
		\item $term$ yang perlu ditentukan jenis nya ($type$)
		\item usulan $type$ untuk $term$
	\end{itemize}

    \emph{Type Judgment} biasaya ditulis secara formal sebagai berikut:
    $$  \Gamma \vdash t : T$$

    dengan $\Gamma$ adalah \emph{type environment}, $t$ adalah $term$ dan $T$ adalah  $type$.

    Penulisan $\Gamma, x : T$ artinya, {\it type environment} menyatakan
    bahwa
    $x$ bertipe $T$ dan tipe dari variable lain masih berada dalam $\Gamma$.

\end{frame}


\subsection{Inference System}
\begin{frame}{Inference System}{Simple Type \lc }

	Dalam \emph{type system} untuk melakukan validitas dari tipe sesuai dengan \emph{type judgment}, dibuatlah \emph{inference system} yang biasanya terdiri dari:


	\begin{itemize}
		\item Sebuah  \emph{axiom} yang berisi sebuah \emph{type judgment}, yang biasanya buat garis lurus diatasnya.
		\item sebuah \emph{inference rule} terdiri dari sebuah \emph{type judgment} (yang menyatakan kesimpulan), yang diberi garis diatasnya. Diatas garis bisa berada satu atau lebih \emph{type judgments } yang disebut  \emph{premises}).
		Sebuah axiom bisa dlihat sebagai \emph{inference rule} tanpa premises.
	\end{itemize}

\end{frame}


\begin{frame}{Inference System}{Simple Type \lc }

	\begin{gather}
	\begin{gathered}[b]
	\hline
	\Gamma, x : T \vdash  x :T
	\end{gathered} \\
	\begin{gathered}[b]
	\Gamma \vdash t : U \to T \qquad
	\Gamma \vdash u : U \\
	\hline
	\Gamma \vdash tu : T
	\end{gathered} \label{stlc:Tapp}\\
	\begin{gathered}[b]
	\Gamma, x:U \vdash t : T\\
	\hline
	\Gamma \vdash (\lambda {x : U} \cdot t) : U \to T
	\end{gathered} \\
	\intertext{Untuk lambda calculus yang sudah berikan ekstension literal terkait numeric aritmatika (dalam contoh ini simbol operator $+$ dan tipe $Num$ ) akan memiliki tambahan aturan:}
	\begin{gathered}[b]
	\hline
	\Gamma \vdash c : \mathbf{Num}
	\end{gathered} \\
	\begin{gathered}[b]
	\Gamma \vdash t : \mathbf{Num} \qquad
	\Gamma \vdash u : \mathbf{Num} \\
	\hline
	\Gamma \vdash t+u : \mathbf{Num}
	\end{gathered}
	\end{gather}

Sebuah penetapan tipe yang tidak bisa diturunkan menggunakan sistem tersebut biasa disebut sebagai \emph{ill-typed}.


\end{frame}

\begin{frame}{Contoh: type inferencing}{SImple Type \lc }


\begingroup\small%
\[
\mathit{avg} : \mathbf{Num} \to\mathbf{Num} \to\mathbf{Num} \vdash
(\lambda f : \mathbf{Num} \to \mathbf{Num} \cdot f\,3) (\mathit{avg}\,2)
: \mathbf{Num}
\]
\endgroup%

 \begingroup\tiny%
 \[
 \begin{gathered}
 \begin{gathered}[b]
 \begin{gathered}[b]
 \begin{gathered}[b]
 \hline
 \mathit{avg} : \cdots,
 f : \beta
 \vdash
 f
 :  \delta \to \alpha
 \end{gathered}
 \qquad
 \begin{gathered}[b]
 \hline
 \mathit{avg} : \cdots,
 f : \cdots
 \vdash
 3
 : \delta
 \end{gathered}
 \\
 \hline
 \mathit{avg} : \cdots,
 f : \beta
 \vdash
 f\,3
 : \alpha
 \end{gathered}\\
 \hline
 \mathit{avg} : \cdots
 \vdash
 (\lambda f : \beta \cdot f\,3)
 : \beta \to \alpha
 \end{gathered}
 \qquad
 \begin{gathered}[b]
 \begin{gathered}[b]
 \hline
 \mathit{avg} : \mathbf{Num} \to\mathbf{Num} \to\mathbf{Num} \vdash
 \mathit{avg}
 :  \gamma \to \beta
 \end{gathered}
 \qquad
 \begin{gathered}[b]
 \hline
 \mathit{avg} : \cdots
 \vdash
 2
 : \gamma
 \end{gathered}
 \\
 \hline
 \mathit{avg} :  \mathbf{Num} \to\mathbf{Num} \to\mathbf{Num}
 \vdash
 \mathit{avg}\,2
 : \beta
 \end{gathered}
 \\
 \hline
 \mathit{avg} : \mathbf{Num} \to\mathbf{Num} \to\mathbf{Num} \vdash
 (\lambda f : \beta \cdot f\,3) (\mathit{avg}\,2)
 : \alpha
 \end{gathered}
 \]
 \endgroup%

\end{frame}


\begin{frame}{Contoh: type inferencing (lanj.)}{Simple Type \lc }
	  \begingroup\tiny%
	  \[
	  \begin{gathered}
	  \begin{gathered}[b]
	  \begin{gathered}[b]
	  \begin{gathered}[b]
	  \hline
	  \mathit{avg} : \cdots,
	  f : \mathbf{Num} \to \mathbf{Num}
	  \vdash
	  f
	  :  \mathbf{Num} \to \mathbf{Num}
	  \end{gathered}
	  \qquad
	  \begin{gathered}[b]
	  \hline
	  \mathit{avg} : \cdots,
	  f : \cdots
	  \vdash
	  3
	  : \mathbf{Num}
	  \end{gathered}
	  \\
	  \hline
	  \mathit{avg} : \cdots,
	  f : \mathbf{Num} \to \mathbf{Num}
	  \vdash
	  f\,3
	  : \mathbf{Num}
	  \end{gathered}\\
	  \hline
	  \mathit{avg} : \cdots
	  \vdash
	  (\lambda f : \mathbf{Num} \to \mathbf{Num} \cdot f\,3)
	  : \mathbf{Num} \to \mathbf{Num}
	  \end{gathered}
	  \qquad
	  \begin{gathered}[b]
	  \begin{gathered}[b]
	  \hline
	  \mathit{avg} : \mathbf{Num} \to\mathbf{Num} \to\mathbf{Num} \vdash
	  \mathit{avg}
	  :  \mathbf{Num} \to\mathbf{Num} \to\mathbf{Num}
	  \end{gathered}
	  \qquad
	  \begin{gathered}[b]
	  \hline
	  \mathit{avg} : \cdots
	  \vdash
	  2
	  : \mathbf{Num}
	  \end{gathered}
	  \\
	  \hline
	  \mathit{avg} :  \mathbf{Num} \to\mathbf{Num} \to\mathbf{Num}
	  \vdash
	  \mathit{avg}\,2
	  : \mathbf{Num}
	  \end{gathered}
	  \\
	  \hline
	  \mathit{avg} : \mathbf{Num} \to\mathbf{Num} \to\mathbf{Num} \vdash
	  (\lambda f : \mathbf{Num} \to \mathbf{Num} \cdot f\,3) (\mathit{avg}\,2)
	  : \mathbf{Num}
	  \end{gathered}
	  \]
	  \endgroup%

	Bentuk penulisan seperti ini biasa disebut \emph{type inference tree}.

\end{frame}


\begin{frame}{Contoh:  ill typed}{Simple Type \lc }

	Ada kasus ketika \emph{type inference tree} tidak sampai pada aksiom. Untuk kasus tersebut kita menyatakan bahwa type yang hendak diuji sebagai \emph{ill typed}. Perhatikan bagian kanan tidak mencapai aksiom, ditandai dengan tidak ada garis diatas nya.

	  \begingroup\tiny%
	  \[
	  \begin{gathered}
	  \begin{gathered}[b]
	  \begin{gathered}[b]
	  \begin{gathered}[b]
	  \hline
	  \mathit{avg} : \cdots,
	  f : \mathbf{Num} \to \mathbf{Num}
	  \vdash
	  f
	  :  \mathbf{Num} \to \mathbf{Num}
	  \end{gathered}
	  \qquad
	  \begin{gathered}[b]
	  \hline
	  \mathit{avg} : \cdots,
	  f : \cdots
	  \vdash
	  3
	  : \mathbf{Num}
	  \end{gathered}
	  \\
	  \hline
	  \mathit{avg} : \cdots,
	  f : \mathbf{Num} \to \mathbf{Num}
	  \vdash
	  f\,3
	  : \mathbf{Num}
	  \end{gathered}\\
	  \hline
	  \mathit{avg} : \cdots
	  \vdash
	  (\lambda f : \mathbf{Num} \to \mathbf{Num} \cdot f\,3)
	  : \mathbf{Num} \to \mathbf{Num}
	  \end{gathered}
	  \qquad
	  \begin{gathered}[b]
	  \mathit{avg} :  \mathbf{Num} \to\mathbf{Num} \to\mathbf{Num}
	  \vdash
	  \mathit{avg}
	  : \mathbf{Num}
	  \end{gathered}
	  \\
	  \hline
	  \mathit{avg} : \mathbf{Num} \to\mathbf{Num} \to\mathbf{Num} \vdash
	  (\lambda f : \mathbf{Num} \to \mathbf{Num} \cdot f\,3) \mathit{avg}
	  : \mathbf{Num}
	  \end{gathered}
	  \]
	  \endgroup%



\end{frame}

\begin{frame}{Contoh: mengusul kan tipe baru}{Simple Type \lc }

	Kadang kita belum tahu semua kemungkinan tipe, kita dapat mengusulkan perkiraan tipe terlebih dahulu kemudian menguji apakah usulan tersebut dalam membentuk susunan yang valid atau \emph{ill typed}. Biasanya menggunakan huruf kecil yunani. Dalam contoh ini kita akan dapati: $\alpha = \gamma = \delta = \mathbf{Num}$

	\begingroup\tiny%
	\[
	\begin{gathered}
	\begin{gathered}[b]
	\begin{gathered}[b]
	\begin{gathered}[b]
	\hline
	\mathit{avg} : \cdots,
	f : \beta
	\vdash
	f
	:  \delta \to \alpha
	\end{gathered}
	\qquad
	\begin{gathered}[b]
	\hline
	\mathit{avg} : \cdots,
	f : \cdots
	\vdash
	3
	: \delta
	\end{gathered}
	\\
	\hline
	\mathit{avg} : \cdots,
	f : \beta
	\vdash
	f\,3
	: \alpha
	\end{gathered}\\
	\hline
	\mathit{avg} : \cdots
	\vdash
	(\lambda f : \beta \cdot f\,3)
	: \beta \to \alpha
	\end{gathered}
	\qquad
	\begin{gathered}[b]
	\begin{gathered}[b]
	\hline
	\mathit{avg} : \mathbf{Num} \to\mathbf{Num} \to\mathbf{Num} \vdash
	\mathit{avg}
	:  \gamma \to \beta
	\end{gathered}
	\qquad
	\begin{gathered}[b]
	\hline
	\mathit{avg} : \cdots
	\vdash
	2
	: \gamma
	\end{gathered}
	\\
	\hline
	\mathit{avg} :  \mathbf{Num} \to\mathbf{Num} \to\mathbf{Num}
	\vdash
	\mathit{avg}\,2
	: \beta
	\end{gathered}
	\\
	\hline
	\mathit{avg} : \mathbf{Num} \to\mathbf{Num} \to\mathbf{Num} \vdash
	(\lambda f : \beta \cdot f\,3) (\mathit{avg}\,2)
	: \alpha
	\end{gathered}
	\]
	\endgroup%

\end{frame}

\section{Latihan}
\begin{frame}{Latihan: $\beta$-reduction }{\lc}

	\begin{enumerate}
		\item<1-> $(\lambda x. (x y)) (\lambda z. z)$
		\item<2-> $(\lambda x. (\lambda y. x y) x) (\lambda z. w) $
		\item<3-> $(\lambda f.  (\lambda g. (f f) g) (\lambda h. k h) ) (\lambda x y. y)$
		\item<4-> $((\lambda z. z) (\lambda y. y y)) ((\lambda x. x) a)$
		\item<5-> $(\lambda x y. x y) y z	$
	\end{enumerate}


\end{frame}

\begin{frame}{Latihan: Type System}{\lc}

	Buktikan bahwa tipe berikut ini benar atau tidak.


	\begin{enumerate}
	    \item<1->  $(\lambda (x:int). (\lambda (y:int). x + y))$
		\item<2-> $(\lambda (f:((int\to string)\to int\to string)) (g:(int\to string)) (x:int). ((f g) x))$
		\item<3-> $(\lambda (f:(int\to int\to string)) (g:(int\to int)) (x:int) (y:int). ((f x) (g y)))$
		\item<4-> $(\lambda (f:((string\to int\to string)\to int\to string)) (x:(int\to string)) (a:int) (y:(string\to int\to string)). (y (x a)))$
		\item<5-> $(\lambda (x:(int\to int)) (y:int). x x (y + 3))$
	\end{enumerate}

\end{frame}


\end{document}


%%%%%
%%%## template
\begin{frame}{template}{}

	\begin{enumerate}
		\item<1-> Permasalahan dengan GOTO \textit{statement} (diakui, sudah ditinggalkan)
		\item<2-> Permasalahan dengan \textbf{pointers}  (diakui, mulai ditinggalkan)
		\item<3-> \alert{Permasalahan dengan \textbf{STATE}} (diakui, belum ditinggalkan)
		\item<4-> Permasalahan dengan OO (masih diteliti, diperdebatkan)
	\end{enumerate}
	\alert{Baca: http://blog.cleancoder.com}
	\begin{itemize}
		\item Berawal dari tulisan Edsger Dijkstra. Makalah klasik: “Go To Statement Considered Harmful”
		dan beberapa makalah.
		\item Dijkstra menunjukkan permasalah dengan GOTO dan mengganti dengan \textit{control flow }seperti if/then/else and while loops.
		\item Setiap perintah GOTO bisa digantikan dengan if/then/else dan loop, sehingga membuat pembacaan dan perancangan program menjadi lebih mudah dan terstrukturu.
		\item Berkembangnya bahasa struktural, seperti C, Pascal.
	\end{itemize}
\end{frame}
